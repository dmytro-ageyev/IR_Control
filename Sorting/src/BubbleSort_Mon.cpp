/**
 * @file BubbleSort_Mon.cpp
 * @brief Реалізація сортування масиву цілих чисел методом бульбашки з моніторингом процесу через Serial.
 *
 * Цей файл містить функцію BubbleSort_Mon, яка виконує сортування масиву цілих чисел
 * методом бульбашки та детально виводить процес сортування у Serial Monitor для відлагодження.
 */

#include "BubbleSort_Mon.h"

/**
 * @brief Сортує масив цілих чисел методом «Бульбашки» з детальним покроковим виводом процесу через Serial Monitor.
 *
 * Алгоритм «Бульбашка» (Bubble Sort) — це один із найпростіших методів сортування.
 * Його суть полягає у послідовному порівнянні сусідніх елементів масиву
 * та їхньому обміні місцями, якщо вони розташовані у неправильному порядку.
 *
 * Після кожного повного проходу по масиву найбільший (або найменший — залежно від напрямку сортування)
 * елемент «спливає» у свій правильний кінець, тому назва методу — "бульбашка".
 *
 * У цій реалізації функція не лише сортує масив, а й:
 * - Виводить повідомлення про початок і завершення кожного проходу.
 * - Демонструє усі виконані обміни елементів.
 * - Показує проміжний стан масиву після кожного обміну.
 * - Повідомляє, якщо під час проходу не було жодного обміну (масив уже відсортований).
 * - Показує елемент, який «сплив» на своє місце після кожного проходу.
 *
 * Таким чином, користувач може в реальному часі спостерігати за логікою алгоритму.
 *
 * @param arr  Масив цілих чисел, який потрібно відсортувати.
 * @param size Кількість елементів у масиві (розмір масиву).
 *
 * @note
 *  - Алгоритм має часову складність O(n²), тому ефективний лише для невеликих масивів.
 *  - Додаткової пам’яті не потребує (O(1)).
 *  - Дана реалізація призначена для навчальних цілей і не оптимізована для великих даних.
 *
 * @example
 *  int data[] = {5, 2, 9, 1, 5, 6};
 *  BubbleSort_Mon(data, 6);
 *
 *  // Результат у Serial Monitor:
 *  // === Початок сортування методом 'Бульбашки' ===
 *  // Прохід №1
 *  //   Обмін елементів 1 і 2: 2    5    9    1    5    6
 *  //   ...
 *  // === Сортування завершено ===
 */
void BubbleSort_Mon(int arr[], int size)
{
  // Початкове повідомлення про старт алгоритму
  Serial.println("=== Початок сортування методом 'Бульбашки' ===\r\n");

  // ===== Зовнішній цикл =====
  // Відповідає за кількість проходів по масиву.
  // Після кожного проходу найбільший елемент переміщується в кінець.
  for (int i = 0; i < size - 1; i++)
  {
    Serial.print("Прохід №");
    Serial.println(i + 1);
    Serial.println("----------------------------");

    bool swapped = false; // Прапорець для відстеження виконаних обмінів

    // ===== Внутрішній цикл =====
    // Порівнює пари сусідніх елементів: arr[j] та arr[j+1]
    // і за потреби міняє їх місцями.
    for (int j = 0; j < size - i - 1; j++)
    {
      // Виведення порівнюваних елементів
      Serial.print("  Порівнюємо arr[");
      Serial.print(j);
      Serial.print("] = ");
      Serial.print(arr[j]);
      Serial.print(" та arr[");
      Serial.print(j + 1);
      Serial.print("] = ");
      Serial.println(arr[j + 1]);

      // Якщо поточний елемент більший за наступний — виконуємо обмін
      if (arr[j] > arr[j + 1])
      {
        Serial.println("  → Умову виконано: arr[j] > arr[j+1], виконується обмін.");

        // Тимчасова змінна для збереження значення arr[j]
        int temp = arr[j];
        arr[j] = arr[j + 1];
        arr[j + 1] = temp;

        swapped = true; // Фіксуємо, що відбувся обмін

        // Вивід стану масиву після обміну
        Serial.println("  Поточний стан масиву після обміну: ");
        for (int k = 0; k < size; k++)
        {
          Serial.print(arr[k]);
          if (k < size - 1)
            Serial.print("\t");
        }
        Serial.println("\r\n"); // Перехід на новий рядок
      }
      else
      {
        Serial.println("  → Обміну не потрібно, порядок правильний.\n");
      }
    }

    // ===== Перевірка на відсутність обмінів =====
    // Якщо за прохід не було жодного обміну — масив уже впорядкований
    if (!swapped)
    {
      Serial.println("  Жодного обміну не відбулося — масив уже впорядкований.\r\n");
      break; // Виходимо з зовнішнього циклу достроково
    }

    // Виведення елемента, який «сплив» у свій кінець після проходу
    Serial.print("  Елемент, що 'сплив' на позицію ");
    Serial.print(size - i - 1);
    Serial.print(": ");
    Serial.println(arr[size - i - 1]);
    Serial.println(); // Порожній рядок для розділення проходів
  }

  // ===== Завершення сортування =====
  Serial.println("=== Сортування завершено ===\r\n");
}

